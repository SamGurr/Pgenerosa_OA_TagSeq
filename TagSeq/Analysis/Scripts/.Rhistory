thresh.d0_2 <- CPM.d0_2 > 10 # Which values in myCPM are greater than 3?
head(thresh.d0_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d0_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d0_2)) # 9631 genes with TRUE in all 8 samples
keep.d0_2 <- rowSums(thresh.d0_2) >= (ncol(thresh.d0_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d0_2) # FALSE 25740 & TRUE 9207 -- more than half of the genes did not pass
cts.matrix.d0_2.filtered <- cts.matrix.d0_2[keep.d0_2,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d0_2.filtered) #  9207 genes & 8 samples
paste( (mean(colSums(cts.matrix.d0_2.filtered))) , (sd(colSums(cts.matrix.d0_2.filtered))), sep ='?')  # mean SD read count per sample
hist_2_d0<-qplot((colSums(cts.matrix.d0_2.filtered)) , geom="histogram")
d0_2_numgenes <- dim(cts.matrix.d0_2.filtered)[1]
d0_2_samp <- dim(cts.matrix.d0_2.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day0_PercAnnot_10cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d0_2.filtered))))) / nrow(cts.matrix.d0_2.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 7 (10 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d7_2 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d7$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d7_2 <- data.frame(cts.merged.d7_2[,-1], row.names=cts.merged.d7_2[,1])
cts.matrix.d7_2  <-as.matrix(cts.merged.d7_2, row.names="transcript_id")
ncol(cts.matrix.d7_2) # 36 samples from just Day 7
colnames(cts.matrix.d7_2) == exp.data.d7$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d7_2
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day7 samples
CPM.d7_2 <- cpm(cts.matrix.d7_2) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d7_2) # Have a look at the output
thresh.d7_2 <- CPM.d7_2 > 10 # Which values in myCPM are greater than 3?
head(thresh.d7_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d7_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d7_2)) # 6880 genes with TRUE in all 36 samples
keep.d7_2 <- rowSums(thresh.d7_2) >= (ncol(thresh.d7_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d7_2) # FALSE 26399  & TRUE 8548 -- more than half of the genes did not pass
cts.matrix.d7_2.filtered <- cts.matrix.d7_2[keep.d7_2,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d7_2.filtered) # 8548 genes & 36 samples
hist_2_d7<-qplot((colSums(cts.matrix.d7_2.filtered)) , geom="histogram")
d7_2_numgenes <- dim(cts.matrix.d7_2.filtered)[1]
d7_2_samp <- dim(cts.matrix.d7_2.filtered)[2]
paste( (mean(colSums(cts.matrix.d7_2.filtered))) , (sd(colSums(cts.matrix.d7_2.filtered))), sep ='?')  # mean SD read count per sample
Day7_PercAnnot_10cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d7_2.filtered))))) / nrow(cts.matrix.d7_2.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 14 (10 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d14_2 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d14$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d14_2 <- data.frame(cts.merged.d14_2[,-1], row.names=cts.merged.d14_2[,1])
cts.matrix.d14_2  <-as.matrix(cts.merged.d14_2, row.names="transcript_id")
ncol(cts.matrix.d14_2) # 35 samples from just Day 14
colnames(cts.matrix.d14_2) == exp.data.d14$Sample.Name # chec if all TRUE; NOTE: SG92 was ommitted earlier to make sure this reads TRUE
UT_seq_map %>% dplyr::filter(Sample.Name == "SG92") # there was no sample in SG92 for TagSeq; 35 total is correct!
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d14_2 <- cpm(cts.matrix.d14_2) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d14_2) # Have a look at the output
thresh.d14_2 <- CPM.d14_2 > 10 # Which values in myCPM are greater than 3?
head(thresh.d14_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d14_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d14_2)) # 6473 genes with TRUE in all 35 samples
keep.d14_2 <- rowSums(thresh.d14_2) >= (ncol(thresh.d14_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d14_2) # FALSE 26321 & TRUE 8626 -- more than half of the genes did not pass
cts.matrix.d14_2.filtered <- cts.matrix.d14_2[keep.d14_2,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d14_2.filtered) # 8626 genes & 35 samples
hist_2_d14<-qplot((colSums(cts.matrix.d14_2.filtered)) , geom="histogram")
d14_2_numgenes <- dim(cts.matrix.d14_2.filtered)[1]
d14_2_samp <- dim(cts.matrix.d14_2.filtered)[2]
paste( (mean(colSums(cts.matrix.d14_2.filtered))) , (sd(colSums(cts.matrix.d14_2.filtered))), sep ='?')  # mean SD read count per sample
Day14_PercAnnot_10cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d14_2.filtered))))) / nrow(cts.matrix.d14_2.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 21  (10 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d21_2 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d21$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d21_2 <- data.frame(cts.merged.d21_2[,-1], row.names=cts.merged.d21_2[,1])
cts.matrix.d21_2  <-as.matrix(cts.merged.d21_2, row.names="transcript_id")
ncol(cts.matrix.d21_2) # # 62 total sampels on day 21
colnames(cts.matrix.d21_2) == exp.data.d21$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d21_2
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d21_2 <- cpm(cts.matrix.d21_2) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d21_2) # Have a look at the output
thresh.d21_2 <- CPM.d21_2 > 10 # filter CPM by threshold
head(thresh.d21_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d21_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d21_2)) # 5219 genes with TRUE in all 62 samples
keep.d21_2 <- rowSums(thresh.d21_2) >= (ncol(thresh.d21_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d21_2) # FALSE 26526 & TRUE 8421 -- more than three quarters of the genes did not pass
cts.matrix.d21_2.filtered <- cts.matrix.d21_2[keep.d21_2,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d21_2.filtered) # 8421 genes &  62 samples
hist_2_d21<-qplot((colSums(cts.matrix.d21_2.filtered)) , geom="histogram")
d21_2_numgenes <- dim(cts.matrix.d21_2.filtered)[1]
d21_2_samp <- dim(cts.matrix.d21_2.filtered)[2]
paste( (mean(colSums(cts.matrix.d21_2.filtered))) , (sd(colSums(cts.matrix.d21_2.filtered))), sep ='?')  # mean SD read count per sample
Day21_PercAnnot_10cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d21_2.filtered))))) / nrow(cts.matrix.d21_2.filtered) * 100), " %", sep = '')
Day21_PercAnnot_10cpm
Day14_PercAnnot_10cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d14_2.filtered))))) / nrow(cts.matrix.d14_2.filtered) * 100), " %", sep = '')
Day14_PercAnnot_10cpm
# prep a table for knitr
filt_cts_table <- data.frame(matrix(nrow = 5, ncol = 6)) # create a new data table
colnames(filt_cts_table)<-c('Time', 'GeneCount_5cpm', 'PercAnnot_5cpm', 'GeneCount_10cpm', 'PercAnnot_10cpm', 'GeneCount_diff_10cpm_5cpm')
# write to table
filt_cts_table$Time <- c("all", "d0", "d7", "d14", "d21")
filt_cts_table$GeneCount_5cpm <- c(all_1_numgenes, d0_1_numgenes, d7_1_numgenes, d14_1_numgenes, d21_1_numgenes)
filt_cts_table$GeneCount_10cpm <- c(all_2_numgenes, d0_2_numgenes, d7_2_numgenes, d14_2_numgenes, d21_2_numgenes)
filt_cts_table$GeneCount_diff_10cpm_5cpm <- c( (all_2_numgenes/all_1_numgenes*100),  (d0_2_numgenes/d0_1_numgenes*100) ,  (d7_2_numgenes/d7_1_numgenes*100),
(d14_2_numgenes/d14_1_numgenes*100),  (d21_2_numgenes/d21_1_numgenes*100) )
filt_cts_table$GeneCount_10cpm <- c(all_2_numgenes, d0_2_numgenes, d7_2_numgenes, d14_2_numgenes, d21_2_numgenes)
# prep a table for knitr
filt_cts_table <- data.frame(matrix(nrow = 5, ncol = 6)) # create a new data table
colnames(filt_cts_table)<-c('Time', 'GeneCount_5cpm', 'PercAnnot_5cpm', 'GeneCount_10cpm', 'PercAnnot_10cpm', 'GeneCount_diff_10cpm_5cpm')
# ==========================================================
#
# DAY 0  (5 CPM in 50% samples using edgeR)
# ==========================================================
# About: run dyplr 'antijoin' to call cts columns that match 'Sample.Name' in the data frame 'exp.data.d0'
cts.merged.d0 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d0$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d0 <- data.frame(cts.merged.d0[,-1], row.names=cts.merged.d0[,1])
cts.matrix.d0  <-as.matrix(cts.merged.d0, row.names="transcript_id")
ncol(cts.matrix.d0) # 8  samples from just Day 0
nrow(cts.matrix.d0) # 34947 total genes
colnames(cts.matrix.d0) == exp.data.d0$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d0
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day0 samples  - notice the read sums are around 1 million
CPM.d0 <- cpm(cts.matrix.d0) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d0) # Have a look at the output
thresh.d0 <- CPM.d0 > 3 # Which values in myCPM are greater than 3?
head(thresh.d0) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d0)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d0)) # 9631 genes with TRUE in all 8 samples
keep.d0 <- rowSums(thresh.d0) >= (ncol(thresh.d0)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d0) # FALSE 22283 & TRUE 12664 -- half of the genes did not pass
cts.matrix.d0.filtered <- cts.matrix.d0[keep.d0,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d0.filtered) # 12664 genes & 8 samples
hist_1_d0<-qplot((colSums(cts.matrix.d0.filtered)) , geom="histogram")
d0_1_numgenes <- dim(cts.matrix.d0.filtered)[1]
d0_1_samp <- dim(cts.matrix.d0.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day0_PercAnnot_3cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d0.filtered))))) / nrow(cts.matrix.d0.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 7 (5 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d7 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d7$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d7 <- data.frame(cts.merged.d7[,-1], row.names=cts.merged.d7[,1])
cts.matrix.d7  <-as.matrix(cts.merged.d7, row.names="transcript_id")
ncol(cts.matrix.d7) # 36 samples from just Day 7
colnames(cts.matrix.d7) == exp.data.d7$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d7
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day7 samples
CPM.d7 <- cpm(cts.matrix.d7) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d7) # Have a look at the output
thresh.d7 <- CPM.d7 > 3 # Which values in myCPM are greater than 3?
head(thresh.d7) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d7)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d7)) # 6880 genes with TRUE in all 36 samples
keep.d7 <- rowSums(thresh.d7) >= (ncol(thresh.d7)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d7) # FALSE 22934 & TRUE 12013 -- more than half of the genes did not pass
cts.matrix.d7.filtered <- cts.matrix.d7[keep.d7,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d7.filtered) # 12013 genes & 36 samples
hist_1_d7<-qplot((colSums(cts.matrix.d7.filtered)) , geom="histogram")
d7_1_numgenes <- dim(cts.matrix.d7.filtered)[1]
d7_1_samp <- dim(cts.matrix.d7.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day7_PercAnnot_3cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d7.filtered))))) / nrow(cts.matrix.d7.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 14 (5 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d14 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d14$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d14 <- data.frame(cts.merged.d14[,-1], row.names=cts.merged.d14[,1])
cts.matrix.d14  <-as.matrix(cts.merged.d14, row.names="transcript_id")
ncol(cts.matrix.d14) # 35 samples from just Day 14
colnames(cts.matrix.d14) == exp.data.d14$Sample.Name # chec if all TRUE; NOTE: SG92 was ommitted earlier to make sure this reads TRUE
UT_seq_map %>% dplyr::filter(Sample.Name == "SG92") # there was no sample in SG92 for TagSeq; 35 total is correct!
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d14 <- cpm(cts.matrix.d14) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d14) # Have a look at the output
thresh.d14 <- CPM.d14 > 3 # Which values in myCPM are greater than 3?
head(thresh.d14) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d14)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d14)) # 6473 genes with TRUE in all 35 samples
keep.d14 <- rowSums(thresh.d14) >= (ncol(thresh.d14)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d14) # FALSE 22812 & TRUE 12135 -- more than half of the genes did not pass
cts.matrix.d14.filtered <- cts.matrix.d14[keep.d14,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d14.filtered) # 12135 genes & 35 samples
hist_1_d14<-qplot((colSums(cts.matrix.d14.filtered)) , geom="histogram")
d14_1_numgenes <- dim(cts.matrix.d14.filtered)[1]
d14_1_samp <- dim(cts.matrix.d14.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day14_PercAnnot_3cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d14.filtered))))) / nrow(cts.matrix.d14.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 21  (5 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d21 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d21$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d21 <- data.frame(cts.merged.d21[,-1], row.names=cts.merged.d21[,1])
cts.matrix.d21  <-as.matrix(cts.merged.d21, row.names="transcript_id")
ncol(cts.matrix.d21) # # 62 total sampels on day 21
colnames(cts.matrix.d21) == exp.data.d21$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d21
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d21 <- cpm(cts.matrix.d21) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d21) # Have a look at the output
thresh.d21 <- CPM.d21 > 3 # filter CPM by threshold
head(thresh.d21) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d21)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d21)) # 5219 genes with TRUE in all 62 samples
keep.d21 <- rowSums(thresh.d21) >= (ncol(thresh.d21)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d21) # FALSE 23147 & TRUE 11800 -- more than three quarters of the genes did not pass
cts.matrix.d21.filtered <- cts.matrix.d21[keep.d21,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d21.filtered) # 11800 genes &  62 samples
hist_1_d21<-qplot((colSums(cts.matrix.d21.filtered)) , geom="histogram")
d21_1_numgenes <- dim(cts.matrix.d21.filtered)[1]
d21_1_samp <- dim(cts.matrix.d21.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day21_PercAnnot_3cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d21.filtered))))) / nrow(cts.matrix.d21.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 0  (5 CPM in 50% samples using edgeR)
# ==========================================================
# About: run dyplr 'antijoin' to call cts columns that match 'Sample.Name' in the data frame 'exp.data.d0'
cts.merged.d0 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d0$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d0 <- data.frame(cts.merged.d0[,-1], row.names=cts.merged.d0[,1])
cts.matrix.d0  <-as.matrix(cts.merged.d0, row.names="transcript_id")
ncol(cts.matrix.d0) # 8  samples from just Day 0
nrow(cts.matrix.d0) # 34947 total genes
colnames(cts.matrix.d0) == exp.data.d0$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d0
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day0 samples  - notice the read sums are around 1 million
CPM.d0 <- cpm(cts.matrix.d0) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d0) # Have a look at the output
thresh.d0 <- CPM.d0 > 5 # Which values in myCPM are greater than 3?
head(thresh.d0) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d0)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d0)) # 9631 genes with TRUE in all 8 samples
keep.d0 <- rowSums(thresh.d0) >= (ncol(thresh.d0)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d0) # FALSE 22283 & TRUE 12664 -- half of the genes did not pass
cts.matrix.d0.filtered <- cts.matrix.d0[keep.d0,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d0.filtered) # 12664 genes & 8 samples
hist_1_d0<-qplot((colSums(cts.matrix.d0.filtered)) , geom="histogram")
d0_1_numgenes <- dim(cts.matrix.d0.filtered)[1]
d0_1_samp <- dim(cts.matrix.d0.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day0_PercAnnot_5cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d0.filtered))))) / nrow(cts.matrix.d0.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 7 (5 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d7 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d7$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d7 <- data.frame(cts.merged.d7[,-1], row.names=cts.merged.d7[,1])
cts.matrix.d7  <-as.matrix(cts.merged.d7, row.names="transcript_id")
ncol(cts.matrix.d7) # 36 samples from just Day 7
colnames(cts.matrix.d7) == exp.data.d7$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d7
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day7 samples
CPM.d7 <- cpm(cts.matrix.d7) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d7) # Have a look at the output
thresh.d7 <- CPM.d7 > 5 # Which values in myCPM are greater than 3?
head(thresh.d7) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d7)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d7)) # 6880 genes with TRUE in all 36 samples
keep.d7 <- rowSums(thresh.d7) >= (ncol(thresh.d7)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d7) # FALSE 22934 & TRUE 12013 -- more than half of the genes did not pass
cts.matrix.d7.filtered <- cts.matrix.d7[keep.d7,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d7.filtered) # 12013 genes & 36 samples
hist_1_d7<-qplot((colSums(cts.matrix.d7.filtered)) , geom="histogram")
d7_1_numgenes <- dim(cts.matrix.d7.filtered)[1]
d7_1_samp <- dim(cts.matrix.d7.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day7_PercAnnot_5cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d7.filtered))))) / nrow(cts.matrix.d7.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 14 (5 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d14 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d14$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d14 <- data.frame(cts.merged.d14[,-1], row.names=cts.merged.d14[,1])
cts.matrix.d14  <-as.matrix(cts.merged.d14, row.names="transcript_id")
ncol(cts.matrix.d14) # 35 samples from just Day 14
colnames(cts.matrix.d14) == exp.data.d14$Sample.Name # chec if all TRUE; NOTE: SG92 was ommitted earlier to make sure this reads TRUE
UT_seq_map %>% dplyr::filter(Sample.Name == "SG92") # there was no sample in SG92 for TagSeq; 35 total is correct!
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d14 <- cpm(cts.matrix.d14) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d14) # Have a look at the output
thresh.d14 <- CPM.d14 > 5 # Which values in myCPM are greater than 3?
head(thresh.d14) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d14)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d14)) # 6473 genes with TRUE in all 35 samples
keep.d14 <- rowSums(thresh.d14) >= (ncol(thresh.d14)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d14) # FALSE 22812 & TRUE 12135 -- more than half of the genes did not pass
cts.matrix.d14.filtered <- cts.matrix.d14[keep.d14,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d14.filtered) # 12135 genes & 35 samples
hist_1_d14<-qplot((colSums(cts.matrix.d14.filtered)) , geom="histogram")
d14_1_numgenes <- dim(cts.matrix.d14.filtered)[1]
d14_1_samp <- dim(cts.matrix.d14.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day14_PercAnnot_5cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d14.filtered))))) / nrow(cts.matrix.d14.filtered) * 100), " %", sep = '')
# ==========================================================
#
# DAY 21  (5 CPM in 50% samples using edgeR)
# ==========================================================
cts.merged.d21 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d21$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d21 <- data.frame(cts.merged.d21[,-1], row.names=cts.merged.d21[,1])
cts.matrix.d21  <-as.matrix(cts.merged.d21, row.names="transcript_id")
ncol(cts.matrix.d21) # # 62 total sampels on day 21
colnames(cts.matrix.d21) == exp.data.d21$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d21
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d21 <- cpm(cts.matrix.d21) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d21) # Have a look at the output
thresh.d21 <- CPM.d21 > 5 # filter CPM by threshold
head(thresh.d21) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d21)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d21)) # 5219 genes with TRUE in all 62 samples
keep.d21 <- rowSums(thresh.d21) >= (ncol(thresh.d21)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d21) # FALSE 23147 & TRUE 11800 -- more than three quarters of the genes did not pass
cts.matrix.d21.filtered <- cts.matrix.d21[keep.d21,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d21.filtered) # 11800 genes &  62 samples
hist_1_d21<-qplot((colSums(cts.matrix.d21.filtered)) , geom="histogram")
d21_1_numgenes <- dim(cts.matrix.d21.filtered)[1]
d21_1_samp <- dim(cts.matrix.d21.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
Day21_PercAnnot_5cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d21.filtered))))) / nrow(cts.matrix.d21.filtered) * 100), " %", sep = '')
# prep a table for knitr
filt_cts_table <- data.frame(matrix(nrow = 5, ncol = 6)) # create a new data table
colnames(filt_cts_table)<-c('Time', 'GeneCount_5cpm', 'PercAnnot_5cpm', 'GeneCount_10cpm', 'PercAnnot_10cpm', 'GeneCount_diff_10cpm_5cpm')
# write to table
filt_cts_table$Time <- c("all", "d0", "d7", "d14", "d21")
filt_cts_table$GeneCount_5cpm <- c(all_1_numgenes, d0_1_numgenes, d7_1_numgenes, d14_1_numgenes, d21_1_numgenes)
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
cts.matrix.all <- raw_counts.matrix
hist_1_all <- hist(colSums(cts.matrix.all)) # view the colSums of our all samples  - notice the read sums are around 1 million
CPM.all <- cpm(cts.matrix.all) # Obtain CPMs (counts oer million) using egdeR
head(CPM.all) # Have a look at the output
thresh.all <- CPM.all > 5 # Which values in myCPM are greater than 3?
head(thresh.all) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.all)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.all)) # 2618 genes with TRUE in all 141 samples
keep.all <- rowSums(thresh.all) >= (ncol(thresh.all)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.all) # FALSE 23057 & TRUE  11890 -- half of the genes did not pass
cts.matrix.all.filtered <- cts.matrix.all[keep.all,] # Subset the rows of countdata to keep the more highly expressed genes
hist_1_all<-qplot((colSums(cts.matrix.all.filtered)) , geom="histogram")
all_1_numgenes <- dim(cts.matrix.all.filtered)[1]
all_1_samp <- dim(cts.matrix.all.filtered)[2]
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
cts.matrix.all_2 <- raw_counts.matrix
hist_2_all <- hist(colSums(cts.matrix.all_2)) # view the colSums of our all samples  - notice the read sums are around 1 million
CPM.all_2 <- cpm(cts.matrix.all_2) # Obtain CPMs (counts oer million) using egdeR
head(CPM.all_2) # Have a look at the output
thresh.all_2 <- CPM.all_2 > 10 # Which values in myCPM are greater than 3?
head(thresh.all_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.all_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.all_2)) # 2618 genes with TRUE in all 141 samples
keep.all_2 <- rowSums(thresh.all_2) >= (ncol(thresh.all_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.all_2) # FALSE 26487 & TRUE  8460 -- more than 2/3 of the genes did not pass
cts.matrix.all_2.filtered <- cts.matrix.all_2[keep.all_2,] # Subset the rows of countdata to keep the more highly expressed genes
hist_2_all<-qplot((colSums(cts.matrix.all_2.filtered)) , geom="histogram")
all_2_numgenes <- dim(cts.matrix.all_2.filtered)[1]
all_2_samp <- dim(cts.matrix.all_2.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
All_PercAnnot_10cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all_2.filtered))))) / nrow(cts.matrix.all_2.filtered) * 100), " %", sep = '')
paste( (mean(colSums(cts.matrix.all_2.filtered))) , (sd(colSums(cts.matrix.all_2.filtered))), sep ='?')  # mean SD read count per sample
# write to table
filt_cts_table$Time <- c("all", "d0", "d7", "d14", "d21")
filt_cts_table$GeneCount_5cpm <- c(all_1_numgenes, d0_1_numgenes, d7_1_numgenes, d14_1_numgenes, d21_1_numgenes)
filt_cts_table$GeneCount_10cpm <- c(all_2_numgenes, d0_2_numgenes, d7_2_numgenes, d14_2_numgenes, d21_2_numgenes)
filt_cts_table$GeneCount_diff_10cpm_5cpm <- c( (all_2_numgenes/all_1_numgenes*100),  (d0_2_numgenes/d0_1_numgenes*100) ,  (d7_2_numgenes/d7_1_numgenes*100),
(d14_2_numgenes/d14_1_numgenes*100),  (d21_2_numgenes/d21_1_numgenes*100) )
filt_cts_table$PercAnnot_5cpm   <- c(All_PercAnnot_5cpm,Day0_PercAnnot_5cpm,Day7_PercAnnot_5cpm,Day14_PercAnnot_5cpm, Day21_PercAnnot_5cpm)
All_PercAnnot_10cpm
Day0_PercAnnot_10cpm
Day0_PercAnnot_5cpm
All_PercAnnot_5cpm
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
All_PercAnnot_5cpm <- paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all.filtered))))) / nrow(cts.matrix.all.filtered) * 100), " %", sep = '')
filt_cts_table$PercAnnot_5cpm   <- c(All_PercAnnot_5cpm,Day0_PercAnnot_5cpm,Day7_PercAnnot_5cpm,Day14_PercAnnot_5cpm, Day21_PercAnnot_5cpm)
filt_cts_table$PercAnnot_10cpm  <- c(All_PercAnnot_10cpm,Day0_PercAnnot_10cpm,Day7_PercAnnot_10cpm,Day14_PercAnnot_10cpm, Day21_PercAnnot_10cpm)
filt_cts_table
mean(filt_cts_table$GeneCount_10cpm)
sd(filt_cts_table$GeneCount_10cpm)
mean(filt_cts_table$PercAnnot_10cpm)
mean(filt_cts_table$PercAnnot_10cpm)
filt_cts_table
mean(c(72.35,71.55,72.01,72.33,72.57))
sd(c(72.35,71.55,72.01,72.33,72.57))
filt_cts_table
d0_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day0.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d0_filt_10CPM  <- d0_filt_10CPM[,-1]
d7_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day7.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d7_filt_10CPM  <- d7_filt_10CPM[,-1]
d14_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day14.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d14_filt_10CPM  <- d14_filt_10CPM[,-1]
d21_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day21.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d21_filt_10CPM  <- d21_filt_10CPM[,-1]
# Mean +- SD filtered read counts for 10 CPM 50% filtered data
d0means  <- as.data.frame(colMeans(d0_filt_10CPM))
rownames(d0means)<-NULL
colnames(d0means) <- "mean"
d7means  <- as.data.frame(colMeans(d7_filt_10CPM))
rownames(d7means)<-NULL
colnames(d7means) <- "mean"
d14means <- as.data.frame(colMeans(d14_filt_10CPM))
rownames(d14means)<-NULL
colnames(d14means) <- "mean"
d21means <- as.data.frame(colMeans(d21_filt_10CPM))
rownames(d21means)<-NULL
colnames(d21means) <- "mean"
meanMaster_10cpm <-rbind(d0means, d7means, d14means, d21means)
colMeans(meanMaster_10cpm)
colSdDiffs(meanMaster_10cpm)
meanMaster_10cpm
meanMaster_10cpm
d0means
# Mean +- SD filtered read counts for 10 CPM 50% filtered data
d0means  <- as.data.frame(colMeans(d0_filt_10CPM))
d0means
d0_filt_10CPM
meanMaster_10cpm <-rbind(d0means, d7means, d14means, d21means)
meanMaster_10cpm
colMeans(meanMaster_10cpm)
colSdDiffs(meanMaster_10cpm)
# Sum  read counts for 10 CPM 50% filtered data
d0sum  <- as.data.frame(colSums(d0_filt_10CPM))
rownames(d0sum)<-NULL
colnames(d0sum) <- "sum"
d7sum  <- as.data.frame(colSums(d7_filt_10CPM))
rownames(d7sum)<-NULL
colnames(d7sum) <- "sum"
d14sum <- as.data.frame(colSums(d14_filt_10CPM))
rownames(d14sum)<-NULL
colnames(d14sum) <- "sum"
d21sum <- as.data.frame(colSums(d21_filt_10CPM))
rownames(d21sum)<-NULL
colnames(d21sum) <- "sum"
sumMaster_10cpm <-rbind(d0sum, d7sum, d14sum, d21sum)
colMeans(sumMaster_10cpm)
colSdDiffs(sumMaster_10cpm)
install.packages('colStats')
install.packages('tineSeries')
install.packages('timeSeries')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(dplyr)
library(edgeR)
library(cowplot)
library(ggplot2)
print(getwd())  # working directory is the scipts folder
# path for output ting all .csv filtered count files
path = 'C:/Users/samjg/Documents/Github_repositories/Pgenerosa_TagSeq_Metabolomics/TagSeq/Analysis/Data/Filtered_Counts' # run this for all count matrix outputs!!!
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(dplyr)
library(edgeR)
library(cowplot)
library(ggplot2)
print(getwd())  # working directory is the scipts folder
# path for output ting all .csv filtered count files
path = 'C:/Users/samjg/Documents/Github_repositories/Pgenerosa_TagSeq_Metabolomics/TagSeq/Analysis/Data/Filtered_Counts' # run this for all count matrix outputs!!!
# write to table
filt_cts_table$Time <- c("all", "d0", "d7", "d14", "d21")
filt_cts_table$GeneCount_5cpm <- c(all_1_numgenes, d0_1_numgenes, d7_1_numgenes, d14_1_numgenes, d21_1_numgenes)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
d0_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day0.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d0_filt_10CPM  <- d0_filt_10CPM[,-1]
d7_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day7.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d7_filt_10CPM  <- d7_filt_10CPM[,-1]
d14_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day14.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d14_filt_10CPM  <- d14_filt_10CPM[,-1]
d21_filt_10CPM  <- read.csv("../Data/Filtered_Counts/10cpm_50perc/day21.counts.filtered_10cpm50perc.csv", sep=',', header=TRUE)
d21_filt_10CPM  <- d21_filt_10CPM[,-1]
# Mean +- SD filtered read counts for 10 CPM 50% filtered data
d0means  <- as.data.frame(colMeans(d0_filt_10CPM))
rownames(d0means)<-NULL
colnames(d0means) <- "mean"
d7means  <- as.data.frame(colMeans(d7_filt_10CPM))
rownames(d7means)<-NULL
colnames(d7means) <- "mean"
d14means <- as.data.frame(colMeans(d14_filt_10CPM))
rownames(d14means)<-NULL
colnames(d14means) <- "mean"
d21means <- as.data.frame(colMeans(d21_filt_10CPM))
rownames(d21means)<-NULL
colnames(d21means) <- "mean"
meanMaster_10cpm <-rbind(d0means, d7means, d14means, d21means)
colMeans(meanMaster_10cpm)
colSdDiffs(meanMaster_10cpm)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(timeSeries)
colSdDiffs(meanMaster_10cpm)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
install.packages('matrixStats')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(matrixStats)
colSdDiffs(meanMaster_10cpm)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# Sum  read counts for 10 CPM 50% filtered data
d0sum  <- as.data.frame(colSums(d0_filt_10CPM))
rownames(d0sum)<-NULL
colnames(d0sum) <- "sum"
d7sum  <- as.data.frame(colSums(d7_filt_10CPM))
rownames(d7sum)<-NULL
colnames(d7sum) <- "sum"
d14sum <- as.data.frame(colSums(d14_filt_10CPM))
rownames(d14sum)<-NULL
colnames(d14sum) <- "sum"
d21sum <- as.data.frame(colSums(d21_filt_10CPM))
rownames(d21sum)<-NULL
colnames(d21sum) <- "sum"
sumMaster_10cpm <-rbind(d0sum, d7sum, d14sum, d21sum)
colMeans(sumMaster_10cpm)
colSdDiffs(sumMaster_10cpm)
d0sum
d7sum
sumMaster_10cpm
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
min(sumMaster_10cpm)
max(sumMaster_10cpm)
sumMaster_10cpm
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
View(sumMaster_10cpm)
