ncol(raw_counts.merged.as.table) # 142 counting the transcript.ID that we want to keep!
# READ COUNTS
dim(raw_counts.matrix) # 34947 total genes 141 samples
sum(raw_counts.matrix) # 113637063 total read counts
gene_sums <- data.frame(rowSums(raw_counts.matrix))  # all gene.IDs and the sum of unique reads
transcript_sums <- colSums(raw_counts.matrix) # sum of reads for each sample
mean(transcript_sums) # 805936.6 == average raw read counts for each sample
gene_sums_gtr0 <- rowSums(raw_counts.matrix) > 0 # all gene.IDs with at least one unique read
sum(gene_sums_gtr0 == TRUE) # 29318 total genes with unique transcript reads
( sum(gene_sums_gtr0 == TRUE) / (dim(raw_counts.matrix)[1]) ) *100 # 83.89275 % of genes have a unique mapped read
ncol(raw_counts.merged.as.table) # 142 counting the transcript.ID that we want to keep!
raw_counts.merged.as.table
# READ COUNTS
dim(raw_counts.matrix) # 34947 total genes 141 samples
sum(raw_counts.matrix) # 113637063 total read counts
transcript_sums <- colSums(raw_counts.matrix) # sum of reads for each sample
mean(transcript_sums) # 805936.6 == average raw read counts for each sample
gene_sums_gtr0 <- rowSums(raw_counts.matrix) > 0 # all gene.IDs with at least one unique read
sum(gene_sums_gtr0 == TRUE) # 29318 total genes with unique transcript reads
( sum(gene_sums_gtr0 == TRUE) / (dim(raw_counts.matrix)[1]) ) *100 # 83.89275 % of genes have a unique mapped read
raw.cts.all <- raw_counts.matrix
raw.cts.d7 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d7$Sample.Name, colnames(raw_counts.merged.as.table))))]
raw.cts.d7 <- data.frame(raw.cts.d7[,-1], row.names=raw.cts.d7[,1])
raw.cts.d7  <-as.matrix(raw.cts.d7, row.names="transcript_id")
ncol(raw.cts.d7) # 36  samples from just Day 7
nrow(raw.cts.d7) # 34947 total genes
colnames(raw.cts.d7) == exp.data.d7$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d0
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
cts.matrix.all <- raw_counts.matrix
hist_1_all <- hist(colSums(cts.matrix.all)) # view the colSums of our all samples  - notice the read sums are around 1 million
CPM.all <- cpm(cts.matrix.all) # Obtain CPMs (counts oer million) using egdeR
head(CPM.all) # Have a look at the output
thresh.all <- CPM.all > 5 # Which values in myCPM are greater than 3?
head(thresh.all) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.all)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.all)) # 2618 genes with TRUE in all 141 samples
keep.all <- rowSums(thresh.all) >= (ncol(thresh.all)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.all) # FALSE 23057 & TRUE  11890 -- half of the genes did not pass
cts.matrix.all.filtered <- cts.matrix.all[keep.all,] # Subset the rows of countdata to keep the more highly expressed genes
hist_1_all<-qplot((colSums(cts.matrix.all.filtered)) , geom="histogram")
all_1_numgenes <- dim(cts.matrix.all.filtered)[1]
all_1_samp <- dim(cts.matrix.all.filtered)[2]
all_1_samp
smpl_ref
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
Geoduck_annotation <- read.delim2(file="C:/Users/samjg/Documents/My_Projects/Pgenerosa_TagSeq_Metabolomics/TagSeq/Seq_details/Panopea-generosa-genes-annotations.txt", header=F)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
nrow(Geoduck_annotation)
all_1_samp
cts.matrix.d0.filtered
cts.matrix.all.filtered
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
rownames(cts.matrix.d0.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
row.names(cts.matrix.d0.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
rownames(cts.matrix.d0.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
row.names(cts.matrix.d0.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(data.frame)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(dataframe)
row.names(cts.matrix.d0.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
library(dplyr)
library(edgeR)
library(cowplot)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
rownames(cts.matrix.d0.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
rownames(cts.matrix.all.filtered)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
head(Geoduck_annotation)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
Geoduck_annotationOM <- na.omit(Geoduck_annotation)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
head(Geoduck_annotation)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
nrow( Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all.filtered))))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
paste( (nrow( Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all.filtered)))) / nrow(cts.matrix.all.filtered) / 100), " %", sep = '')
(nrow( Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all.filtered))))
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all.filtered))))) / nrow(cts.matrix.all.filtered) / 100), " %", sep = '')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all.filtered))))) / nrow(cts.matrix.all.filtered) * 100), " %", sep = '')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# About: run dyplr 'antijoin' to call cts columns that match 'Sample.Name' in the data frame 'exp.data.d0'
cts.merged.d0 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d0$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d0 <- data.frame(cts.merged.d0[,-1], row.names=cts.merged.d0[,1])
cts.matrix.d0  <-as.matrix(cts.merged.d0, row.names="transcript_id")
ncol(cts.matrix.d0) # 8  samples from just Day 0
nrow(cts.matrix.d0) # 34947 total genes
colnames(cts.matrix.d0) == exp.data.d0$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d0
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day0 samples  - notice the read sums are around 1 million
CPM.d0 <- cpm(cts.matrix.d0) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d0) # Have a look at the output
thresh.d0 <- CPM.d0 > 5 # Which values in myCPM are greater than 3?
head(thresh.d0) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d0)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d0)) # 9631 genes with TRUE in all 8 samples
keep.d0 <- rowSums(thresh.d0) >= (ncol(thresh.d0)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d0) # FALSE 22283 & TRUE 12664 -- half of the genes did not pass
cts.matrix.d0.filtered <- cts.matrix.d0[keep.d0,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d0.filtered) # 12664 genes & 8 samples
hist_1_d0<-qplot((colSums(cts.matrix.d0.filtered)) , geom="histogram")
d0_1_numgenes <- dim(cts.matrix.d0.filtered)[1]
d0_1_samp <- dim(cts.matrix.d0.filtered)[2]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d0.filtered))))) / nrow(cts.matrix.d0.filtered) * 100), " %", sep = '')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
cts.merged.d7 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d7$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d7 <- data.frame(cts.merged.d7[,-1], row.names=cts.merged.d7[,1])
cts.matrix.d7  <-as.matrix(cts.merged.d7, row.names="transcript_id")
ncol(cts.matrix.d7) # 36 samples from just Day 7
colnames(cts.matrix.d7) == exp.data.d7$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d7
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day7 samples
CPM.d7 <- cpm(cts.matrix.d7) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d7) # Have a look at the output
thresh.d7 <- CPM.d7 > 5 # Which values in myCPM are greater than 3?
head(thresh.d7) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d7)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d7)) # 6880 genes with TRUE in all 36 samples
keep.d7 <- rowSums(thresh.d7) >= (ncol(thresh.d7)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d7) # FALSE 22934 & TRUE 12013 -- more than half of the genes did not pass
cts.matrix.d7.filtered <- cts.matrix.d7[keep.d7,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d7.filtered) # 12013 genes & 36 samples
hist_1_d7<-qplot((colSums(cts.matrix.d7.filtered)) , geom="histogram")
d7_1_numgenes <- dim(cts.matrix.d7.filtered)[1]
d7_1_samp <- dim(cts.matrix.d7.filtered)[2]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d7.filtered))))) / nrow(cts.matrix.d7.filtered) * 100), " %", sep = '')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
cts.merged.d14 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d14$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d14 <- data.frame(cts.merged.d14[,-1], row.names=cts.merged.d14[,1])
cts.matrix.d14  <-as.matrix(cts.merged.d14, row.names="transcript_id")
ncol(cts.matrix.d14) # 35 samples from just Day 14
colnames(cts.matrix.d14) == exp.data.d14$Sample.Name # chec if all TRUE; NOTE: SG92 was ommitted earlier to make sure this reads TRUE
UT_seq_map %>% dplyr::filter(Sample.Name == "SG92") # there was no sample in SG92 for TagSeq; 35 total is correct!
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d14 <- cpm(cts.matrix.d14) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d14) # Have a look at the output
thresh.d14 <- CPM.d14 > 5 # Which values in myCPM are greater than 3?
head(thresh.d14) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d14)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d14)) # 6473 genes with TRUE in all 35 samples
keep.d14 <- rowSums(thresh.d14) >= (ncol(thresh.d14)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d14) # FALSE 22812 & TRUE 12135 -- more than half of the genes did not pass
cts.matrix.d14.filtered <- cts.matrix.d14[keep.d14,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d14.filtered) # 12135 genes & 35 samples
hist_1_d14<-qplot((colSums(cts.matrix.d14.filtered)) , geom="histogram")
d14_1_numgenes <- dim(cts.matrix.d14.filtered)[1]
d14_1_samp <- dim(cts.matrix.d14.filtered)[2]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d14.filtered))))) / nrow(cts.matrix.d14.filtered) * 100), " %", sep = '')
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d7.filtered))))) / nrow(cts.matrix.d7.filtered) * 100), " %", sep = '')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
cts.merged.d21 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d21$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d21 <- data.frame(cts.merged.d21[,-1], row.names=cts.merged.d21[,1])
cts.matrix.d21  <-as.matrix(cts.merged.d21, row.names="transcript_id")
ncol(cts.matrix.d21) # # 62 total sampels on day 21
colnames(cts.matrix.d21) == exp.data.d21$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d21
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
CPM.d21 <- cpm(cts.matrix.d21) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d21) # Have a look at the output
thresh.d21 <- CPM.d21 > 5 # filter CPM by threshold
head(thresh.d21) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d21)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d21)) # 5219 genes with TRUE in all 62 samples
keep.d21 <- rowSums(thresh.d21) >= (ncol(thresh.d21)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d21) # FALSE 23147 & TRUE 11800 -- more than three quarters of the genes did not pass
cts.matrix.d21.filtered <- cts.matrix.d21[keep.d21,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d21.filtered) # 11800 genes &  62 samples
hist_1_d21<-qplot((colSums(cts.matrix.d21.filtered)) , geom="histogram")
d21_1_numgenes <- dim(cts.matrix.d21.filtered)[1]
d21_1_samp <- dim(cts.matrix.d21.filtered)[2]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d21.filtered))))) / nrow(cts.matrix.d21.filtered) * 100), " %", sep = '')
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
cts.matrix.all_2 <- raw_counts.matrix
hist_2_all <- hist(colSums(cts.matrix.all_2)) # view the colSums of our all samples  - notice the read sums are around 1 million
CPM.all_2 <- cpm(cts.matrix.all_2) # Obtain CPMs (counts oer million) using egdeR
head(CPM.all_2) # Have a look at the output
thresh.all_2 <- CPM.all_2 > 10 # Which values in myCPM are greater than 3?
head(thresh.all_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.all_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.all_2)) # 2618 genes with TRUE in all 141 samples
keep.all_2 <- rowSums(thresh.all_2) >= (ncol(thresh.all_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.all_2) # FALSE 26487 & TRUE  8460 -- more than 2/3 of the genes did not pass
cts.matrix.all_2.filtered <- cts.matrix.all_2[keep.all_2,] # Subset the rows of countdata to keep the more highly expressed genes
hist_2_all<-qplot((colSums(cts.matrix.all_2.filtered)) , geom="histogram")
all_2_numgenes <- dim(cts.matrix.all_2.filtered)[1]
all_2_samp <- dim(cts.matrix.all_2.filtered)[2]
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.all_2.filtered))))) / nrow(cts.matrix.all_2.filtered) * 100), " %", sep = '')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
# About: run dyplr 'antijoin' to call cts columns that match 'Sample.Name' in the data frame 'exp.data.d0_2'
cts.merged.d0_2 <- raw_counts.merged.as.table[,c(1,na.omit(match(exp.data.d0$Sample.Name, colnames(raw_counts.merged.as.table))))]
cts.merged.d0_2 <- data.frame(cts.merged.d0_2[,-1], row.names=cts.merged.d0_2[,1])
cts.matrix.d0_2  <-as.matrix(cts.merged.d0_2, row.names="transcript_id")
ncol(cts.matrix.d0_2) # 8  samples from just Day 0
nrow(cts.matrix.d0_2) # 34947 total genes
colnames(cts.matrix.d0_2) == exp.data.d0$Sample.Name # check if TRUE, means the same as the exp/design dataframe exp.data.d0_2
# pre-filtering; genes ommitted if < 3 counts per million reads in 50% of samples
# view the colSums of our Day0 samples  - notice the read sums are around 1 million
CPM.d0_2 <- cpm(cts.matrix.d0_2) # Obtain CPMs (counts oer million) using egdeR
head(CPM.d0_2) # Have a look at the output
thresh.d0_2 <- CPM.d0_2 > 10 # Which values in myCPM are greater than 3?
head(thresh.d0_2) # This produces a logical matrix with TRUEs and FALSES
rowSums(head(thresh.d0_2)) # Summary of how many TRUEs there are in each row
table(rowSums(thresh.d0_2)) # 9631 genes with TRUE in all 8 samples
keep.d0_2 <- rowSums(thresh.d0_2) >= (ncol(thresh.d0_2)/2) # we would like to keep genes that have at least 50% TRUES in each row of thresh
summary(keep.d0_2) # FALSE 25740 & TRUE 9207 -- more than half of the genes did not pass
cts.matrix.d0_2.filtered <- cts.matrix.d0_2[keep.d0_2,] # Subset the rows of countdata to keep the more highly expressed genes
dim(cts.matrix.d0_2.filtered) #  9207 genes & 8 samples
hist_2_d0<-qplot((colSums(cts.matrix.d0_2.filtered)) , geom="histogram")
d0_2_numgenes <- dim(cts.matrix.d0_2.filtered)[1]
d0_2_samp <- dim(cts.matrix.d0_2.filtered)[2]
# % Genes with annotation == (filtered genes with annotation / filtered genes) * 100
paste( ( (nrow(Geoduck_annotationOM %>% dplyr::filter(V1  %in% (rownames(cts.matrix.d0_2.filtered))))) / nrow(cts.matrix.d0_2.filtered) * 100), " %", sep = '')
, 2021"
---
# LOAD PACKAGES
library(dplyr)
library(DESeq2)
library(tidyselect)
library(reshape2)
library(ggplot2)
library(gridExtra)
library(ggpubr)
# SET WORKING DIRECTORY AND LOAD DATA
setwd("C:/Users/samjg/Documents/My_Projects/Pgenerosa_TagSeq_Metabolomics/TagSeq/")
# LOAD DATA
# count data
day7.counts.matrix <- read.csv(file="Analysis/Data/Filtered_Counts/5cpm_50perc/day7.counts.filtered_5cpm50perc.csv", sep=',', header=TRUE)
day14.counts.matrix <- read.csv(file="Analysis/Data/Filtered_Counts/5cpm_50perc/day14.counts.filtered_5cpm50perc.csv", sep=',', header=TRUE)
day21.counts.matrix <- read.csv(file="Analysis/Data/Filtered_Counts/5cpm_50perc/day21.counts.filtered_5cpm50perc.csv", sep=',', header=TRUE)
# trait data
Master.Treatment_Phenotype.data <- read.csv(file="Analysis/Data/Experiment_Metadata/Master_Phyenotype.and.Exp.Treatment_Metadata.csv", sep=',', header=TRUE)
# WGCNA results
D7_WGCNA<- read.csv(file="Analysis/Output/WGCNA/Day7/d7.WGCNA_ModulMembership.csv", sep=',', header=TRUE)
D14_WGCNA<- read.csv(file="Analysis/Output/WGCNA/Day14/d14.WGCNA_ModulMembership.csv", sep=',', header=TRUE)
D21_WGCNA<- read.csv(file="Analysis/Output/WGCNA/Day21/d21.WGCNA_ModulMembership.csv", sep=',', header=TRUE)
D7_WGCNA$Day  <- "Day7"
D14_WGCNA$Day <- "Day14"
D21_WGCNA$Day <- "Day21"
# DESEq2 results
D7_DEGs_PrimEffect  <- read.csv(file="Analysis/Output/DESeq2/10cpm/Day7/DE_Day7_Primary.csv", sep=',', header=TRUE)  %>% dplyr::select(c('Row.names', 'log2FoldChange', 'pvalue', 'up', 'down'))
D14_DEGs_PrimEffect <- read.csv(file="Analysis/Output/DESeq2/10cpm/Day14/DE_Day14_Primary.csv", sep=',', header=TRUE) %>% dplyr::select(c('Row.names', 'log2FoldChange', 'pvalue', 'up', 'down'))
D21_DEGs_PrimEffect <- read.csv(file="Analysis/Output/DESeq2/10cpm/Day21/DE_Day21_Primary.csv", sep=',', header=TRUE) %>% dplyr::select(c('Row.names', 'log2FoldChange', 'pvalue', 'up', 'down'))
D7_DEGs_PrimEffect$Day  <- "Day7"
D14_DEGs_PrimEffect$Day <- "Day14"
D21_DEGs_PrimEffect$Day <- "Day21"
DEGs_PrimEffect_10cpm <- rbind(D7_DEGs_PrimEffect, D14_DEGs_PrimEffect, D21_DEGs_PrimEffect) # bind dataframes
names(DEGs_PrimEffect_10cpm)[1] <- "gene.ID" # change name of column 1
genes <- c('AOX','NADH_dehydrogenase','Cytochrome_c_reductase','Uncoupling_protein_1','Uncoupling_protein_2','Uncoupling_protein_3',
' S-adenosylmethionine_synthase_isoform_type-2','DNMT_1','DNMT3A','DNMT_3b','HMT_1','HMT_2','positiv_hist_methyl','positiv_hist_methyl_2','methyltransferase','HAT_1','HAT_2','HAT_3','HAT_4','HAT_5',
'SIR1','SIR2','SIR4','SIR5','SIR6','SIR7',
'SOD_1','SOD_2','SOD_3','SOD_Cu_chaperone','SOD_Mn_act','glutathione_peroxidase_1','glutathione_peroxidase_2','glutathione_peroxidase_3','glutathione_peroxidase_4', 'glutathione_peroxidase_5','glutathione_peroxidase_6',
'titin', 'calpain')
GeneID <- c('PGEN_.00g108770', 'PGEN_.00g299160', 'PGEN_00g275780','PGEN_.00g063670', 'PGEN_.00g193030', 'PGEN_.00g230260', # MITCHONDRIAL PLAYERS
'PGEN_.00g041430'  , 'PGEN_.00g283000','PGEN_.00g029420','PGEN_.00g067800','PGEN_.00g053100','PGEN_.00g053120','PGEN_.00g064910', 'PGEN_.00g064920','PGEN_.00g066460', 'PGEN_.00g283340',  'PGEN_.00g311570', 'PGEN_.00g320700', 'PGEN_.00g338440','PGEN_.00g272910', # TRANASCRIPTIONAL REGULATION - proteins involved in methylation and histone modification(s)
'PGEN_.00g048200', 'PGEN_.00g012340', 'PGEN_.00g149480', 'PGEN_.00g153700', 'PGEN_.00g144540', 'PGEN_.00g033970',# SIRTUINS
'PGEN_.00g010160', 'PGEN_.00g065700', 'PGEN_.00g257600', 'PGEN_.00g015070', 'PGEN_.00g062450', 'PGEN_.00g293960', 'PGEN_.00g287800', 'PGEN_.00g192250','PGEN_.00g180320', 'PGEN_.00g116940','PGEN_.00g049360',# OXIDATIVE STRESS
'PGEN_.00g066340',  'PGEN_.00g014370')
target_GOIs <- data.frame(genes, GeneID)
# use 'any_of' in tidyselect package to get any of the target GOIs present - may have been cut in the filtering process
Day7.ExpVST_GOIs <- Day7.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', any_of(target_GOIs$GeneID))
Day7.ExpVST_GOIs$group <- paste(Day7.ExpVST_GOIs$Primary_Treatment , Day7.ExpVST_GOIs$Second_Treament , sep='')
Day14.ExpVST_GOIs <- Day14.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', any_of(target_GOIs$GeneID))
Day14.ExpVST_GOIs$group <- paste(Day14.ExpVST_GOIs$Primary_Treatment , Day14.ExpVST_GOIs$Second_Treament , sep='')
Day21.ExpVST_GOIs <- Day21.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'Third_Treatment', any_of(target_GOIs$GeneID))
Day21.ExpVST_GOIs$group <- paste(Day21.ExpVST_GOIs$Primary_Treatment , Day21.ExpVST_GOIs$Second_Treament , Day21.ExpVST_GOIs$Third_Treatment,  sep='')
# ===================================================================================
#
# PLOTTING - DATA PREP FOR PLOTS
#
# ===================================================================================
# treatment data
d7.Treatment_data <- Master.Treatment_Phenotype.data %>%   dplyr::filter(Date %in% 20190731) %>%  dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament') # split for day 7 data
d14.Treatment_data <- Master.Treatment_Phenotype.data  %>%  dplyr::filter(Date %in% 20190807) %>%  dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament')# split for day 7 data
d21.Treatment_data <- Master.Treatment_Phenotype.data  %>%  dplyr::filter(Date %in% 20190814) %>%  dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'Third_Treatment')# split for day 7 data
# ================================================================================== #
# count data - day  7
d7.data = as.data.frame(t(day7.counts.matrix[, -(1)])) # ommit all columns but samples and transpose
names(d7.data) = day7.counts.matrix$X # assigns column names (previous jsut numbered) as the gene ID
rownames(d7.data) = names(day7.counts.matrix)[-(1)]; # assigns the row names as the sample ID
d7.data_matrix <- data.frame(day7.counts.matrix[,-1], row.names=day7.counts.matrix[,1])
d7.data_matrix_t <- t(d7.data_matrix)
dds.d7 <- DESeqDataSetFromMatrix(countData = d7.data_matrix,  colData = d7.Treatment_data, design = ~ 1)
dds.d7_vst <- vst(dds.d7) # transform it vst
dds.d7_vst <- assay(dds.d7_vst) # call only the transformed coutns in the dds object
d7_vst <- t(dds.d7_vst) # transpose columns to rows and vice versa
# fix(d7_vst)
# =================================================================================== #
# count data - day  14
d14.data = as.data.frame(t(day14.counts.matrix[, -(1)])) # ommit all columns but samples and transpose
names(d14.data) = day14.counts.matrix$X # assigns column names (previous jsut numbered) as the gene ID
rownames(d14.data) = names(day14.counts.matrix)[-(1)]; # assigns the row names as the sample ID
d14.data_matrix <- data.frame(day14.counts.matrix[,-1], row.names=day14.counts.matrix[,1])
d14.data_matrix_t <- t(d14.data_matrix)
# match number of samples in treatment data - SG92 was not sequenced  - ommit from the treatment data for the dds object
d14.Treatment_data_OM <- d14.Treatment_data %>% dplyr::filter(!Sample.Name %in% 'SG92')
dds.d14 <- DESeqDataSetFromMatrix(countData = d14.data_matrix,  colData = d14.Treatment_data_OM, design = ~ 1)
dds.d14_vst <- vst(dds.d14) # transform it vst
dds.d14_vst <- assay(dds.d14_vst) # call only the transformed coutns in the dds object
d14_vst <- t(dds.d14_vst) # transpose columns to rows and vice versa
# fix(d14_vst)
# =================================================================================== #
# count data - day  21
d21.data = as.data.frame(t(day21.counts.matrix[, -(1)])) # ommit all columns but samples and transpose
names(d21.data) = day21.counts.matrix$X # assigns column names (previous jsut numbered) as the gene ID
rownames(d21.data) = names(day21.counts.matrix)[-(1)]; # assigns the row names as the sample ID
d21.data_matrix <- data.frame(day21.counts.matrix[,-1], row.names=day21.counts.matrix[,1])
d21.data_matrix_t <- t(d21.data_matrix)
dds.d21 <- DESeqDataSetFromMatrix(countData = d21.data_matrix,  colData = d21.Treatment_data, design = ~ 1)
dds.d21_vst <- vst(dds.d21) # transform it vst
dds.d21_vst <- assay(dds.d21_vst) # call only the transformed coutns in the dds object
d21_vst <- t(dds.d21_vst) # transpose columns to rows and vice versa
# fix(d21_vst)
# use 'any_of' in tidyselect package to get any of the target GOIs present - may have been cut in the filtering process
Day7.ExpVST_GOIs <- Day7.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', any_of(target_GOIs$GeneID))
Day7.ExpVST_GOIs$group <- paste(Day7.ExpVST_GOIs$Primary_Treatment , Day7.ExpVST_GOIs$Second_Treament , sep='')
Day14.ExpVST_GOIs <- Day14.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', any_of(target_GOIs$GeneID))
Day14.ExpVST_GOIs$group <- paste(Day14.ExpVST_GOIs$Primary_Treatment , Day14.ExpVST_GOIs$Second_Treament , sep='')
Day21.ExpVST_GOIs <- Day21.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'Third_Treatment', any_of(target_GOIs$GeneID))
Day21.ExpVST_GOIs$group <- paste(Day21.ExpVST_GOIs$Primary_Treatment , Day21.ExpVST_GOIs$Second_Treament , Day21.ExpVST_GOIs$Third_Treatment,  sep='')
Day7.ExpVST
D7_DEGs_PrimEffect
d7_vst_counts <- cbind(rownames(d7_vst), data.frame(d7_vst, row.names=NULL))
colnames(d7_vst_counts)[1] <- "Sample.Name"
Day7.ExpVST <- merge(d7_vst_counts, d7.Treatment_data, by = 'Sample.Name') # merge
d14_vst_counts <- cbind(rownames(d14_vst), data.frame(d14_vst, row.names=NULL))
colnames(d14_vst_counts)[1] <- "Sample.Name"
Day14.ExpVST <- merge(d14_vst_counts, d14.Treatment_data_OM, by = 'Sample.Name') # merge
d21_vst_counts <- cbind(rownames(d21_vst), data.frame(d21_vst, row.names=NULL))
colnames(d21_vst_counts)[1] <- "Sample.Name"
Day21.ExpVST <- merge(d21_vst_counts, d21.Treatment_data, by = 'Sample.Name') # merge
# fix(Day21.ExpVST)
# use 'any_of' in tidyselect package to get any of the target GOIs present - may have been cut in the filtering process
Day7.ExpVST_GOIs <- Day7.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', any_of(target_GOIs$GeneID))
Day7.ExpVST_GOIs$group <- paste(Day7.ExpVST_GOIs$Primary_Treatment , Day7.ExpVST_GOIs$Second_Treament , sep='')
Day14.ExpVST_GOIs <- Day14.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', any_of(target_GOIs$GeneID))
Day14.ExpVST_GOIs$group <- paste(Day14.ExpVST_GOIs$Primary_Treatment , Day14.ExpVST_GOIs$Second_Treament , sep='')
Day21.ExpVST_GOIs <- Day21.ExpVST %>% dplyr::select('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'Third_Treatment', any_of(target_GOIs$GeneID))
Day21.ExpVST_GOIs$group <- paste(Day21.ExpVST_GOIs$Primary_Treatment , Day21.ExpVST_GOIs$Second_Treament , Day21.ExpVST_GOIs$Third_Treatment,  sep='')
pe the data frame and merge geneIDs with tragetGOIs to add back the gene titles - use this to name figures downstream
Day7.ExpVST_GOIs_MELT <- melt(Day7.ExpVST_GOIs, id=(c('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'group'))) # melt using reshape2
names(Day7.ExpVST_GOIs_MELT)[(5:6)] <- c('GeneID', 'vst_Expression') # change column names
Day7_ExpVst_Master <- merge(target_GOIs, Day7.ExpVST_GOIs_MELT, by = 'GeneID')
# calc the m an expressio by gene ID (add gene title in group but this is the same unique level as GeneID - review target_GOIs)
Day7_meanExpr <- Day7_ExpVst_Master %>%
dplyr::select(c('Sample.Name','group', 'vst_Expression', 'GeneID', 'genes')) %>%
group_by(GeneID, group, genes) %>%
dplyr::summarize(mean.vstExp = mean(vst_Expression),
sd.vsdtExp = sd(vst_Expression),
n = n(),
se.vsdtExp = sd.vsdtExp/sqrt(n))
# create treatment groups
Day7_meanExpr$PrimaryTreatment <- substr(Day7_meanExpr$group, 1,1) # primary
Day7_meanExpr$SecondTreatment <- substr(Day7_meanExpr$group, 2,2) # second
# ===================================================================================
# Day 14 data prep for figures
#
# ===================================================================================
# reshape the data frame and merge geneIDs with tragetGOIs to add back the gene titles - use this to name figures downstream
Day14.ExpVST_GOIs_MELT <- melt(Day14.ExpVST_GOIs, id=(c('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'group'))) # melt using reshape2
names(Day14.ExpVST_GOIs_MELT)[(5:6)] <- c('GeneID', 'vst_Expression') # change column names
Day14_ExpVst_Master <- merge(target_GOIs, Day14.ExpVST_GOIs_MELT, by = 'GeneID')
# calc the m an expressio by gene ID (add gene title in group but this is the same unique level as GeneID - review target_GOIs)
Day14_meanExpr <- Day14_ExpVst_Master %>%
dplyr::select(c('Sample.Name','group', 'vst_Expression', 'GeneID', 'genes')) %>%
group_by(GeneID, group, genes) %>%
dplyr::summarize(mean.vstExp = mean(vst_Expression),
sd.vsdtExp = sd(vst_Expression),
n = n(),
se.vsdtExp = sd.vsdtExp/sqrt(n))
# create treatment groups
Day14_meanExpr$PrimaryTreatment <- substr(Day14_meanExpr$group, 1,1) # primary
Day14_meanExpr$SecondTreatment <- substr(Day14_meanExpr$group, 2,2) # second
# ===================================================================================
# Day 21 data prep for figures
#
# ===================================================================================
# reshape the data frame and merge geneIDs with tragetGOIs to add back the gene titles - use this to name figures downstream
Day21.ExpVST_GOIs_MELT <- melt(Day21.ExpVST_GOIs, id=(c('Sample.Name', 'Primary_Treatment', 'Second_Treament', 'Third_Treatment','group'))) # melt using reshape2
names(Day21.ExpVST_GOIs_MELT)[(6:7)] <- c('GeneID', 'vst_Expression') # change column names
Day21_ExpVst_Master <- merge(target_GOIs, Day21.ExpVST_GOIs_MELT, by = 'GeneID')
# calc the m an expressio by gene ID (add gene title in group but this is the same unique level as GeneID - review target_GOIs)
Day21_meanExpr <- Day21_ExpVst_Master %>%
dplyr::select(c('Sample.Name','group', 'vst_Expression', 'GeneID', 'genes')) %>%
group_by(GeneID, group, genes) %>%
dplyr::summarize(mean.vstExp = mean(vst_Expression),
sd.vsdtExp = sd(vst_Expression),
n = n(),
se.vsdtExp = sd.vsdtExp/sqrt(n))
# fix(Day21_meanExpr)
# create treatment groups
Day21_meanExpr$PrimaryTreatment <- substr(Day21_meanExpr$group, 1,1) # primary
Day21_meanExpr$SecondTreatment <- substr(Day21_meanExpr$group, 2,2) # second
Day21_meanExpr$ThirdTreatment <- substr(Day21_meanExpr$group, 3,3) # th
# ===================================================================================
# Now for the for looped plots!
#
# ===================================================================================
pd <- position_dodge(0.3)
for(i in 1:nrow(target_GOIs)) {
if ( (nrow(Day7_meanExpr %>%  dplyr::filter(genes %in% target_GOIs[i,1]))) > 0 ) {
d7_plots <- Day7_meanExpr %>%
dplyr::filter(genes %in% target_GOIs[i,1]) %>%
ggplot(aes(x=SecondTreatment, y=mean.vstExp, fill=PrimaryTreatment)) +  # , colour=supp, group=supp))
theme_classic() +
geom_errorbar(aes(ymin=mean.vstExp-se.vsdtExp, ymax=mean.vstExp+se.vsdtExp), colour="black", width=.1, position=pd) +
geom_point(position=pd, size = 4, shape=21) +
xlab("Second pCO2 treatment") +
ylab('') +                 # note the mean was first by sample ID THEN by treatment
scale_fill_manual(values=c("#56B4E9","#E69F00")) +
# scale_color_manual(values=c("#56B4E9","#E69F00")) +
ggtitle(paste("Day 7:",target_GOIs[i,1], sep='')) +
# expand_limits(y=0) +                                                    # Expand y range
#scale_y_continuous(limits=c((min_p1), (max_p1))) +
theme(text = element_text(size=15)) +
theme(legend.position = "none")
} else { d7_plots <- plot.new() }
if ( (nrow(Day14_meanExpr %>%  dplyr::filter(genes %in% target_GOIs[i,1]))) > 0 ) {
d14_plots <- Day14_meanExpr %>%
dplyr::filter(genes %in% target_GOIs[i,1]) %>%
ggplot(aes(x=SecondTreatment, y=mean.vstExp, fill=PrimaryTreatment)) +  # , colour=supp, group=supp))
theme_classic() +
geom_errorbar(aes(ymin=mean.vstExp-se.vsdtExp, ymax=mean.vstExp+se.vsdtExp), colour="black", width=.1, position=pd) +
geom_point(position=pd, size = 4, shape=21) +
xlab("Second pCO2 treatment") +
ylab("Gene Expression (mean±SE VST transformed)") +                 # note the mean was first by sample ID THEN by treatment
scale_fill_manual(values=c("#56B4E9","#E69F00")) +
# scale_color_manual(values=c("#56B4E9","#E69F00")) +
ggtitle(paste("Day 14:",target_GOIs[i,1], sep='')) +
# expand_limits(y=0) +                                                    # Expand y range
#scale_y_continuous(limits=c((min_p1), (max_p1))) +
theme(text = element_text(size=15)) +
theme(legend.position = "none")
} else { d14_plots <- plot.new() }
if ( (nrow(Day21_meanExpr %>%  dplyr::filter(genes %in% target_GOIs[i,1]))) > 0 ) {
d21_plots <- Day21_meanExpr %>%
dplyr::filter(genes %in% target_GOIs[i,1]) %>%
ggplot(aes(x=ThirdTreatment, y=mean.vstExp, fill=PrimaryTreatment)) +  # , colour=supp, group=supp))
theme_classic() +
geom_errorbar(aes(ymin=mean.vstExp-se.vsdtExp, ymax=mean.vstExp+se.vsdtExp), colour="black", width=.1, position=pd) +
geom_point(position=pd, size = 4, shape=21) +
xlab("Third pCO2 treatment") +
ylab('') +                 # note the mean was first by sample ID THEN by treatment
scale_fill_manual(values=c("#56B4E9","#E69F00")) +
# scale_color_manual(values=c("#56B4E9","#E69F00")) +
ggtitle(paste("Day 21:",target_GOIs[i,1], sep='')) +
# expand_limits(y=0) +                                                    # Expand y range
#scale_y_continuous(limits=c((min_p1), (max_p1))) +
theme(text = element_text(size=15)) +
theme(legend.position = "none") +
facet_wrap(~SecondTreatment)
} else { d21_plots <- plot.new() }
getwd()
pdf(paste("Analysis/Output/a_priori_hypothesis/",target_GOIs[i,1],".pdf"), width=10, height=6)
print(ggarrange(d7_plots, d14_plots, d21_plots,
plotlist = NULL,
ncol = 3,
nrow = 1,
labels = NULL))
dev.off()
}
BP_D14$Ont <- "BP" # create a new common clumn to call in the plot
BP_D14$module_day <- factor(BP_D14$module_day, levels = c("Day14_brown", "Day14_black", "Day14_pink", "Day14_magenta"))# reorder the facotr level for the facet wrap plot
BP_D14_filtered <- BP_D14 %>%  dplyr::filter(Gene.Count > 1) # ommit all with gene counts <1
BP_D14_filtered$slim_term <- factor(BP_D14_filtered$slim_term ,levels=rev(unique(BP_D14_filtered$slim_term))) # make slim term alphabetical for plotting
BP_D14_Plot <-ggplot(data = BP_D14_filtered, aes(x = Ont, y = slim_term)) +
geom_tile(aes(fill=Gene.Count, width = 1)) +
scale_fill_gradient(low = "thistle1", high = "steelblue4") +
facet_grid(~module_day, labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
strip.text.y = element_text(angle=0, size = 8, face = "bold"),
strip.text.x = element_text(size = 8, face = "bold"),
axis.title.x = element_blank(),
axis.title.y = element_text(size=8),
axis.text = element_text(size = 8), legend.position = "right",
plot.margin = unit(c(0,1,0,0.25), "cm"))+
ggtitle('GOslim Biological Process: WGCNA Day 14')
MF_D14$Ont <- "MF" # create a new common clumn to call in the plot
MF_D14$module_day <- factor(MF_D14$module_day, levels = c("Day14_brown", "Day14_black", "Day14_pink", "Day14_magenta"))# reorder the facotr level for the facet wrap plot
MF_D14_filtered <- MF_D14 %>%  dplyr::filter(Gene.Count > 1) # ommit all with gene counts <1
MF_D14_filtered$slim_term <- factor(MF_D14_filtered$slim_term ,levels=rev(unique(MF_D14_filtered$slim_term))) # make slim term alphabetical for plotting
MF_D14_Plot <-ggplot(data = MF_D14_filtered, aes(x = Ont, y = slim_term)) +
geom_tile(aes(fill=Gene.Count, width = 1)) +
scale_fill_gradient(low = "azure2", high = "springgreen4") +
facet_grid(~module_day, labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
strip.text.y = element_text(angle=0, size = 8, face = "bold"),
strip.text.x = element_text(size = 8, face = "bold"),
axis.title.x = element_blank(),
axis.title.y = element_text(size=8),
axis.text = element_text(size = 8), legend.position = "right",
plot.margin = unit(c(0,1,0,0.25), "cm"))+
ggtitle('GOslim Molecular Function: WGCNA Day 14')
